# Project Specification
## Work Overview
My goal is to essentially create my own basic programming language with a compiler to complement it, with plans to advance it as far as possible as the development of my project progresses. Initially I will aim to implement basic features (e.g. variables, functions, etc) with more advanced features being kept for further on. I hope to provide users with a language that can be used for educational purposes, with simple syntax that combines the best of popular programming languages and demonstrates the capabilities programming has to offer.  I also hope to combine the simplicity of high-level languages, whilst maintaining the performance of a low-level one.

In terms of technology, more research is currently required. The objective is to convert my original syntax to that of another language, but which language I am unsure. I am most confident in Java, but feel that other languages (such as C++) would be more viable. Either way, I have faith that regardless of the language used I’ll be capable of implementing it into my project.

## Technologies and Materials
For technologies and materials, there are not many requirements for this project. In terms of platforms used, I plan on using GitLab and IntelliJ for building the language. This is flexible however, as it depends on the language which will be used. I do not expect to use any libraries, but again this may be flexible as it depends on how things go during the project’s development. No physical equipment or materials is required, but if there is time and its possible, I will consider making some sort of extension to an Arduino (which I already own). For techniques used it will primarily be compiler theory and design, as well-advanced programming techniques.

As previously stated, the final language to be used has not yet been decided. However, I do currently have my eyes on both C++ and JavaScript. My main issues lie in the fact that whilst C++ is fast its syntax can be more difficult, whilst with JavaScript its syntax is simple yet it performs more slowly. I am currently leaning more towards C++, as the faster nature is appealing. However, I will also consider doing it in Java as I am already proficient in the language, and development would likely be easier overall as a result. I will make my final decision as I further research and get started with development.

## Motivation Research
Inspiration comes from two similar projects I found online: The Pinecone programming language and The Super Tiny Compiler. The former written in C++ with the goal of combining the simplicity of a dynamic language with the performance of a compiled one, the latter being an ultra-simplified example of all the major pieces of a modern compiler written in easy to read JavaScript. Both provide explanations of compilers in regards to how they work, whilst also documenting the developers journey throughout the development of their project. The code for the STC is extra useful, as it provides a vast amount of detailed comments, explaining the code as its executed. These two projects will act as my primary inspirations and guides, as they encompass the simplified yet performative nature I hope to achieve in my own work.

https://github.com/wmww/Pinecone  
https://github.com/jamiebuilds/the-super-tiny-compiler

## Existing Knowledge
The primary modules I’m drawing on knowledge from are my Introduction to Programming, Principles and Applications of Programming, Algorithms and Data Structures, and Software Projects. The first two programming modules have taught me the basic principles of programming languages and how to apply them, particularly in JavaScript and Java. I am, however, adaptable to most other languages and its simply a matter of learning syntax since principles remain largely the same. This knowledge will of course be the most vital to the project, as it mainly revolves around advanced programming.

My algorithms module has extended my programming to problem solving and efficiency, teaching me how to implement data structures for efficient data storage and algorithms for efficient data retrieval. I am expecting to have to implement and use these tools throughout my project if I want to keep it clean and efficient, so I hope to see knowledge from this module being applied here.

Lastly, my software projects module essentially mirrors what the entire development process will be like. In the class we designed and created a piece of software as a group, and now we are doing the same thing but alone. The experience I gained from this module will be extremely valuable, as no step will be entirely new and I can work on issues I had the first time around rather than experiencing them again now.

## New Knowledge
I need to delve deep into the area of compiler theory and design, reading as much on the topic as possible. Fortunately, it seems easy to separate the basics from the more advanced topics, so I’m hopeful that learning will flow well. Understanding what goes on under the hood of a programming language is the key to a successful project development, as that is where I’ll be working for my own one. It may also help to gain new knowledge and experience in regular programming, as it’ll teach me new techniques which could prove useful as things progress.

To acquire these skills, I think the best course of action is to start small and understand the basics. I learn easiest from code and seeing things in action, so I’ll begin by reviewing the two previous inspirations I discussed and understanding how they work. Once I’ve done that and can see the processes which take place, I’ll continue reading the basics about the topic until I’m confident I have a good foundation. At this point I’ll likely be ready to begin experimenting myself, which again helps me vastly in terms of learning. I’ll continue acquiring new knowledge by reading about the more advanced side of things as I develop the project, using popular and well received books such as Compilers: Principles, Techniques, and Tools and Modern Compiler Design.

https://github.com/wmww/Pinecone  
https://github.com/jamiebuilds/the-super-tiny-compiler  
Compilers: Principles, Techniques, and Tools - *Aho, Alfred V., et al. Compilers Principles, Techniques and Tools. Addison-Wesley, 1985.*  
Modern Compiler Design - *Grune, Dick. Modern Compiler Design. Springer, 2016.*

## Timeline and Milestones
| Deadline | Abstract              | Description |
| -------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 01/11/19 | Project Specification | Submit proposal discussing project ideas, technologies and plans.                                                                                                                                                                |
| 18/11/19 | Project Research      | Research the basics of compiler theory and the related online examples, so that foundational knowledge can be formed.                                                                                                            |
| 13/01/19 | Prototyping           | Begin developing and creating my own programming language and compiler in order to gain better knowledge and practice. In this time, also continue researching more advanced topics.                                             |
| 27/03/20 | Draft Report          | Submit a draft of my report for feedback, whilst also having a foundation for the project built by this point. I’m aiming to have the MVP completed by this point, to allow for more advanced development in the remaining time. |
| 22/05/20 | Final Report          | Submit final report. Finish developing project to meet its original goals, using this time to add more advanced features and cleaning things up if necessary.                                                                    |
| 05/06/20 | Project Showcase      | Have a presentation prepared to showcase the project in its entirety, demonstrating its features and capabilities from an external and internal point of view.                                                                   |

As of right now, it is too early to make a detailed plan in regards to talking about when specific things will be researched and what parts of the code will be done. These things can only be known once research has been done and development has begun, and so because of this I will maintain a schedule as development progresses. By keeping this schedule updated with milestones and having a timeline of how things have been done, I will easily be able to add/remove as necessary with specific tasks being given priority.

The minimum viable project I hope to achieve is a working programming language with basic features: variables, conditionals, iterators, arrays. As long as these can be implemented, my minimum viable product will have been achieved.
