# Project Overview
The objective for my project is to create my own compiler, with unique syntax and essentially act as a programming language in its own right. It’s intended to be basic and include: expression evaluation, various operators, conditionals, variables, loops, functions and types. The purpose of this compiler is for educational purposes, with simple syntax that will combine the best of other popular simplistic languages whilst also demonstrating the capabilities modern day programming languages have to offer. I also intend for it to be packaged with error messages more insightful and helpful to those new to programming, so that debugging can be done more effectively by those inexperienced.

My current plan is to write the compiler in JavaScript with a simple web-based user interface, allowing for easy access and quick start-up for users who wish to jump right in without any downloads required. I intend to keep the features included in this UI basic with only a handful of tools, as the goal here is not to overwhelm users too fast. It will also include guides on how to use the language with explanations for how each feature works, as well as examples. However, it’s worth noting that the UI comes secondary and the compiler itself is the primary focus. Dedicating time to develop a high-quality UI will only be done if possible, within the boundaries of deadlines.


# Progress Summary
## Research on Compilers
- Conducted research regarding the basics of compilers and their creation, looking at each of the necessary stages and what each one entails.
- I found that compilers break down into three primary stages: parsing, transformation and code generation. There are also four “stations” of processing to be aware of, which are: lexical analysis, syntactic analysis, code generation and code compilation. I also discovered while there were multiple ways of doing things, most other examples of compilers used specific techniques in how things, such as parsing, were handled.
- I documented a sort of guide for each part of a compiler in my GitLab repository, which was based on The Super Tiny Compiler.

## Researching Technology
- Researched what languages compilers should be written in and the benefits of each one, as I needed to decide what language my compiler would be written in. I also consulted my supervisor on this matter to gather his opinion on the subject.
- Whilst I originally thought about writing my compiler in C++ as it ensured better performance, I found it would be too much of a challenge. Being inexperienced with C++ means I would have to learn the language alongside my work, and concluded it would take up too much time. As a result, I decided to forego chasing optimum performance in favour of a slower but more simple language: JavaScript.
- My research here was from many sources, but a compilation of various articles and guides which I’ve saved can be found within my notes GitHub repository.

## Finding Learning Resources
- Looked for and accumulated various learning resources on building compilers, making notes about the qualities of each one.
- Whilst there are lots of resources on compiler formation, I found that only a few matches the scope I’m looking for. Many are too simple and only focus on a small portion of functionality, others are poorly made and use incorrect techniques, and some are too complex to follow along without prior experience. However, I then found a YouTube series by developer Immo Landwerth, who created a 30-hour long video series detailing the steps of building a compiler with the appropriate scope I’m looking for. I plan to use his series as the first and primary resource when creating my own compiler.
- I documented my experience with searching for learning resources in a previous blog post.

## Practice Prototyping
- Using the video series by Immo Landwerth, began following along and building the compiler with him as a way to get a better understanding of the inner workings.
- After watching and following the first video (at 98 minutes long), I constructed a basic lexer, parser and diagnostics reporter, whilst also understanding exactly how they worked and how the code flowed when receiving a string of syntax. This gave me a much better and clearer understanding for how these initial steps function on a larger scale, and provided confidence for the future in my ability to form my own compiler with the knowledge I’ve gained. I have since continued progressing through the videos, and will continue to do so.
- I documented my thoughts in a blog post after finishing the initial video, and my progress in terms of code from the series can be found in a separate prototyping Git repository.

# Evaluation
My primary milestones for the first term were to research compilers to better understand the steps and processes they go through, come to conclusion on which technologies I wanted to use specifically, and begin prototyping with building a compiler to get a better understanding of they’re programmed. I feel like all three of these have been met, as I: researched compilers stages and got to understand each part one by one, discovered the positives and negatives of each programming language I could use and came to a conclusion as to what would be best for me, and started the process of programming a compiler in C# through the use of an online tutorial. These three aspects I feel have prepared me adequately for what comes next, and that’s the formation of my own compiler in its early stages.

From my initial ideas my project has changed a fair bit, a big one being the language I was going to program it in. As discussed previously, I ultimately decided to choose JavaScript, but I did initially consider C++. This was because at the beginning one of my goals was to focus somewhat on performance by using a low-level language to improve runtime speed. However, I realized that since the purpose of my language is for educational purposes and won’t generally require and/or make a difference visually for the user if its fast or not, I figured it would be best to make development easier and go with a language I’m more experienced with instead. Since I’m also inexperienced with C++ I was advised by my supervisor not to go with it, as learning a new and complex language would be too time consuming.

I also originally intended to have the compiler run in a basic shell-like interface, similar to the Python one, but from an application file. However, since I’ve adopted JavaScript as my language of choice, I decided it may be a good idea to instead have a web-based shell in which users can easily access it. I figured this would be ideal given its application, since ease of use can be important to new programmers since any extra effort can put people off, and a quicker start-up makes it more likely users would stick around.

In terms of scoping during my initial specification, I feel like I did so pretty well. My plan was to focus on implementing the main features of a programming language (e.g. variables, operators, loops, functions, conditionals, etc.) without getting down to the too complex stuff (e.g. classes). From what I’ve learned from my research, I feel confident that look at it on the surface I can implement said features into the final product. However, I am also trying to remain vigilant and am aware that it may not look as simple on the outside. Though even if some of the slightly more complex features do have to be left out in the end, I’d be content with including at least the basic functionality as an MVP. Overall, I feel my current outcomes match up to my expectations for the final work well as everything seems within my scope and possible, whilst also extending my technical capabilities.

In regards to what I’ve learned so far, I’ve already covered it multiple times so to summarize: the stages of a compiler, how each individual stage works, how to start building each stage, and the different language options available with their pros and cons.
